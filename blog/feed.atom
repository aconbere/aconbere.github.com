<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Meat Flappings - Feed</title>
    <link href="http://anders.conbere.org/"/>

    <updated>2011-05-03T18:42:12-07:00</updated>

    <author>
        <name>Anders Conbere</name>
        <email>aconbere@conbere.org</email>
    </author>

    <id>http://anders.conbere.org/</id>
    <link rel="self" href="http://anders.conbere.org/feed.atom" />

    
    <entry>
        <title>Concatinative Versus Object Oriented Design</title>
        <link rel="alternate" href="http://anders.conbere.org/blog/2011/05/03/concatinative_versus_object_oriented_design"/>
        <id>tag:anders.conbere.org,2011-05-03:1304473332.0</id>
        <updated>2011-05-03T18:42:12-07:00</updated>
        <published>2011-05-03T18:42:12-07:00</published>
        <summary type="html"><![CDATA[<p>I finally moved my blog over to using <a href="http://github.com/aconbere/igor">Igor</a> my new static blog generator. A couple of things have fallen out of this work. First is a feeling of two design forces pulling me in opposite directions. I feel torn between the simple semantics of a group of functions and a few monolithic classes. The former doesn't feel particularly pythonic, but the latter doesn't feel particularly well designed.</p>
<p>Having seen some fantastic application design I can tell that Igor isn't the most well designed of programs. There are functions littered in modules that they don't belong, there are classes where there doesn't need to be and no classes where there should be! And I should have seen this coming. I set out on this project with the goal of not designing up front. Instead to build a working tools and to refine it. But I've found that the result is an application that works but lacks beauty.</p>
<p>So let's look at some of the problems here, and some solutions I've been working on.</p>
<p>The primary goal of Igor is to make publishing a simple, relatively static website simple for me. I've decided to accomplish this through simple parsing of text files and some opinionated choices on directory structure. A secondary goal related to the first is to allow me to do this with as little extra effort as possible. I don't want to have to use external scripts, I don't want to type out the date to get the published date, etc. To that end I've decided to make as much use of the Operating System and VCS as possible.</p>
<p>So the design needs to work something like.</p>
<p>Given source and destination directories</p>
<ul>
<li>retrieve the names of all the text files in the _posts directory below it</li>
<li>parse each of them, applying an apporpriate markup filter</li>
<li>publish each post to an appropiately named directory in the destination</li>
</ul>]]></summary>
        <content type="html"><![CDATA[<p>I finally moved my blog over to using <a href="http://github.com/aconbere/igor">Igor</a> my new static blog generator. A couple of things have fallen out of this work. First is a feeling of two design forces pulling me in opposite directions. I feel torn between the simple semantics of a group of functions and a few monolithic classes. The former doesn't feel particularly pythonic, but the latter doesn't feel particularly well designed.</p>
<p>Having seen some fantastic application design I can tell that Igor isn't the most well designed of programs. There are functions littered in modules that they don't belong, there are classes where there doesn't need to be and no classes where there should be! And I should have seen this coming. I set out on this project with the goal of not designing up front. Instead to build a working tools and to refine it. But I've found that the result is an application that works but lacks beauty.</p>
<p>So let's look at some of the problems here, and some solutions I've been working on.</p>
<p>The primary goal of Igor is to make publishing a simple, relatively static website simple for me. I've decided to accomplish this through simple parsing of text files and some opinionated choices on directory structure. A secondary goal related to the first is to allow me to do this with as little extra effort as possible. I don't want to have to use external scripts, I don't want to type out the date to get the published date, etc. To that end I've decided to make as much use of the Operating System and VCS as possible.</p>
<p>So the design needs to work something like.</p>
<p>Given source and destination directories</p>
<ul>
<li>retrieve the names of all the text files in the _posts directory below it</li>
<li>parse each of them, applying an apporpriate markup filter</li>
<li>publish each post to an appropiately named directory in the destination</li>
</ul>
<p>Secondary to that it will also need to</p>
<ul>
<li>copy all files that aren't hidden or start with a _</li>
<li>provide a way to link to articles given an identifier</li>
<li>provide tools for building RSS feeds and Archives</li>
</ul>
<p>The primary design goals turn out to be quite easy. First I retrieved all the files in a dir using os.listdir, then I got the file extension of the file and checked it against a list of extensions mapped to markup filters, and finally I split off a header, title and body section from the file and passed them through the markup filter. Publishing I grabbed the published data and crafted a simple Y/M/D/title/ scheme.</p>
<p>Things became tricky when solving 5 and 6.</p>
<p>For 5 I needed a way to store a canonical list of all the documents I had been working with. I decided to has all the documents I wanted to publish derive from the Document class, which provided the tools to track any new instances, including posts, archives or home_pages. All Documents register a "slug" (a string that removes characters not well suited for uri's) and then can be referenced by that slug. Using that I could then build a valid url given the slug of a given post, and solved 5.</p>
<p>For 6 I needed to collect the posts from 1, and reuse then in generating archives, feeds and home pages. At first I had a class based approach to my overall program. You would intialize the class with the source and destination. It would grab a config file, generate paths, and eventually aid in publishing all the documents. My second attempt I looked at a more concatinative approach. I knew the root of my app was simply a generator expression that yielded up new Posts as files were found in _posts. And I thought I could use that to make a simple design publishing each post as I recieved it. But then 6 came and bit me. To create collections I would have to create a list of posts at the end, regarless of my pretty itterator.</p>
<p>The end result was this rather ugly function...</p>
<pre><code>def publish(source, destination=""):
    paths = prepare_paths(source, destination)
    config = Config(paths['source'])

    paths['destination'] = paths['destination'] or config.get("publish_directory")
    assert(paths['destination'], "A destination directory is required")

    posts_path = path.join(paths['destination'], config.get("posts_prefix"))
    prepare_destination(paths['destination'])

    posts = find_posts(paths['source'], prefix=posts_dir, extensions=list(markup.extensions()))
    docs = posts + [HomePage(posts), Feed(posts), Archive(posts)]

    print(config)
    context = {'documents': documents}
    context.update(config)

    env = environment(paths['templates'], global_context=context)
    [write(doc, env, posts_path) for doc in docs]
    copy_supporting_files(paths['source'], paths['destination'])
</code></pre>
<p>I'll keep working on this, and I'm not sure a beautiful solution exists. But I'm fairly sure it's not what I have there.</p>]]></content>
    </entry>
    
    <entry>
        <title>The Problem Finding Talent</title>
        <link rel="alternate" href="http://anders.conbere.org/blog/2011/05/03/the_problem_finding_talent"/>
        <id>tag:anders.conbere.org,2011-05-03:1304473332.0</id>
        <updated>2011-05-03T18:42:12-07:00</updated>
        <published>2011-05-03T18:42:12-07:00</published>
        <summary type="html"><![CDATA[<p>Finding talent is tough in any field, in the tech field it can be especially hard and there are many forces at play. You need to find someone who works well with a team, who has the enough experience with your domain so that you don't have to spend inordinate amounts of time training, someone who can learn the way your systems work and quickly come up to speed. It's a strange mixture of knowledge, wisdom, raw talent, social aptitude, and a flexible mind. Different situations call for different focuses. A startup might need a very low ramp-up time, someone with lots of experience in the field, and a prove track record. A well established company might be willing to pay the costs to train a worker if they think that in the long run the work they'll do will win out. In the end determining any one of these metrics would be difficult, but collectively they provide a substantial challenge. The difficulty of which is magnified when you step outside of traditional tech fields.</p>
<p>For a small or medium size business without a preexisting technical team hiring a new programmer, web developer or IT staff, it's a treacherous adventure in guess work and gut feelings. Without the necessary knowledge or training to determine technical ability many small business owners are duped by jargon filled talk or a good looking resume. Where as in the technical field we might be fully aware that simple possessing a degree in Computer science does not qualify someone as knowledgeable about their work. Not only that but these kind of decisions pose significant risk to the business. People put into these positions often hold the keys to a company. Credit card transactions, passwords to websites and servers, and contact with customers.</p>
<p>I often thought about this problem while in Seattle and having regular lunch meetings with fledging startups or business folks looking to make the leap into one. Their problem isn't well solved by recruiters since they suffer both from an inability to describe their desired applicants and then an inability to determine if any of the candidates they do encounter are actually qualified. Recruiters traditionally fail in this role because they too often lack the technical knowledge to properly filter candidates, or to rephrase the words of their client to better reach candidates. As a result recruiters take more of a shotgun approach. Sending every remotely qualified candidate their way, which leaves the business owner in approximately the same place as he was before. Lost in a see of talent which he has no way of determining the quality.</p>
<p>In Seattle I considered a small time consultancy. I liked to think of it as lunch time HR. Ask a flat rate and work directly with whoever was doing their hiring to help them work out a good description of the position, and later to work on screening, or working on interviews with them. Basically providing the technical background they lack and desperately need to be able to make a secure hire.</p>]]></summary>
        <content type="html"><![CDATA[<p>Finding talent is tough in any field, in the tech field it can be especially hard and there are many forces at play. You need to find someone who works well with a team, who has the enough experience with your domain so that you don't have to spend inordinate amounts of time training, someone who can learn the way your systems work and quickly come up to speed. It's a strange mixture of knowledge, wisdom, raw talent, social aptitude, and a flexible mind. Different situations call for different focuses. A startup might need a very low ramp-up time, someone with lots of experience in the field, and a prove track record. A well established company might be willing to pay the costs to train a worker if they think that in the long run the work they'll do will win out. In the end determining any one of these metrics would be difficult, but collectively they provide a substantial challenge. The difficulty of which is magnified when you step outside of traditional tech fields.</p>
<p>For a small or medium size business without a preexisting technical team hiring a new programmer, web developer or IT staff, it's a treacherous adventure in guess work and gut feelings. Without the necessary knowledge or training to determine technical ability many small business owners are duped by jargon filled talk or a good looking resume. Where as in the technical field we might be fully aware that simple possessing a degree in Computer science does not qualify someone as knowledgeable about their work. Not only that but these kind of decisions pose significant risk to the business. People put into these positions often hold the keys to a company. Credit card transactions, passwords to websites and servers, and contact with customers.</p>
<p>I often thought about this problem while in Seattle and having regular lunch meetings with fledging startups or business folks looking to make the leap into one. Their problem isn't well solved by recruiters since they suffer both from an inability to describe their desired applicants and then an inability to determine if any of the candidates they do encounter are actually qualified. Recruiters traditionally fail in this role because they too often lack the technical knowledge to properly filter candidates, or to rephrase the words of their client to better reach candidates. As a result recruiters take more of a shotgun approach. Sending every remotely qualified candidate their way, which leaves the business owner in approximately the same place as he was before. Lost in a see of talent which he has no way of determining the quality.</p>
<p>In Seattle I considered a small time consultancy. I liked to think of it as lunch time HR. Ask a flat rate and work directly with whoever was doing their hiring to help them work out a good description of the position, and later to work on screening, or working on interviews with them. Basically providing the technical background they lack and desperately need to be able to make a secure hire.</p>]]></content>
    </entry>
    
    <entry>
        <title>Setup and Teardown Methods With Py.test</title>
        <link rel="alternate" href="http://anders.conbere.org/blog/2011/05/03/setup_and_teardown_methods_with_py.test"/>
        <id>tag:anders.conbere.org,2011-05-03:1304473332.0</id>
        <updated>2011-05-03T18:42:12-07:00</updated>
        <published>2011-05-03T18:42:12-07:00</published>
        <summary type="html"><![CDATA[<p>Not so long ago I picked up my unittest's and headed out for greener pastures. My first stop was <a href="http://code.google.com/p/python-nose/">nosetest</a> but I found that I had a hard time getting all my tests to work. The naming conventions just didn't seem to work out the way I thought they did, and after a day of experimenting I moved onwards. I ended up settling down in a nice little valley called <a href="http://codespeak.net/py/dist/test/index.html">py.test</a>, part of the <a href="http://codespeak.net/py/dist/">py.lib</a> suite of tools. It has much the same flavor as nose tests. There are no explicit classes, all tests are collected via a naming scheme, but it just worked out better for me.</p>
<pre><code>def test_preferences():
    assert("I like py.test")
</code></pre>
<p>My needs were simple, the valley was fertile, life was good.</p>
<p>Now more recently I needed some more complex setup and teardown methods for Igor...and the valley grew a little darker. The documentation for this was split between two versions. Ian Bicking had a <a href="http://ianbicking.org/docs/pytest-presentation/pytest-slides.html">slide deck</a> up that documented using decorators to accomplish this task. But implementing that I got errors about guards. The <a href="http://codespeak.net/py/dist/test/funcargs.html#application-specific-test-setup-and-fixtures">online documentation</a> mentioned something about using funcargs but I really didn't get how it all came together, and didn't mention teardown.</p>
<p>So here's how you do it. </p>
<p>First let's talk a bit about funcargs. Funcargs is a little magic feature that reaches into your function definitions and looks at the arguments a function expects.</p>
<pre><code>def test_my_function(arg):
    assert(arg)
</code></pre>]]></summary>
        <content type="html"><![CDATA[<p>Not so long ago I picked up my unittest's and headed out for greener pastures. My first stop was <a href="http://code.google.com/p/python-nose/">nosetest</a> but I found that I had a hard time getting all my tests to work. The naming conventions just didn't seem to work out the way I thought they did, and after a day of experimenting I moved onwards. I ended up settling down in a nice little valley called <a href="http://codespeak.net/py/dist/test/index.html">py.test</a>, part of the <a href="http://codespeak.net/py/dist/">py.lib</a> suite of tools. It has much the same flavor as nose tests. There are no explicit classes, all tests are collected via a naming scheme, but it just worked out better for me.</p>
<pre><code>def test_preferences():
    assert("I like py.test")
</code></pre>
<p>My needs were simple, the valley was fertile, life was good.</p>
<p>Now more recently I needed some more complex setup and teardown methods for Igor...and the valley grew a little darker. The documentation for this was split between two versions. Ian Bicking had a <a href="http://ianbicking.org/docs/pytest-presentation/pytest-slides.html">slide deck</a> up that documented using decorators to accomplish this task. But implementing that I got errors about guards. The <a href="http://codespeak.net/py/dist/test/funcargs.html#application-specific-test-setup-and-fixtures">online documentation</a> mentioned something about using funcargs but I really didn't get how it all came together, and didn't mention teardown.</p>
<p>So here's how you do it. </p>
<p>First let's talk a bit about funcargs. Funcargs is a little magic feature that reaches into your function definitions and looks at the arguments a function expects.</p>
<pre><code>def test_my_function(arg):
    assert(arg)
</code></pre>
<p>Then using the argument name, matches that against a function defined in a special python module conftest.py. So in this case it would look for.</p>
<pre><code>def pytest_funcarg__arg(request):
    return False
</code></pre>
<p>Now magically the result of pytest_funcarg__arg would show up as "arg" in test_my_function. This alone would solve our setup problem. But figuring out teardown requires that we know a little bit about that request variable. As it turns out this isn't particularly hard either! If for instance we wanted to test a database, installing a set of fixtures and then destroying them after our tests or setup might look like this.</p>
<pre><code># conftest.py
def setup_fixtures():
    db.insert(...)
    return db

def teardown_fixtures(db):
    db.destroy(..)

def py_test_funcarg__db(request):
    return request.cached_setup(
        setup = setup_fixtures,
        teardown = teardown_fixtures,
        scope = "module)

# test_db.py
def test_db(db):
    assert(len(db.query(x=y)) &gt;= 1)
</code></pre>
<p>This cached_setup stores the results of py_test_funcarg__db and reuses it for each test function in a given scope (here we're using module level scope). To instantiate the arg it calls the setup function, and when the scope exists it calls the teardown method with that arg.</p>
<p>I can't claim to like how magic all of this feels, but I do like that it works!</p>]]></content>
    </entry>
    
    <entry>
        <title>Igor Design Part 2</title>
        <link rel="alternate" href="http://anders.conbere.org/blog/2011/05/03/igor_design_part_2"/>
        <id>tag:anders.conbere.org,2011-05-03:1304473332.0</id>
        <updated>2011-05-03T18:42:12-07:00</updated>
        <published>2011-05-03T18:42:12-07:00</published>
        <summary type="html"><![CDATA[<p>In the <a href="http://anders.conbere.org/blog/2009/08/22/concatinative_versus_object_oriented_design/">last post</a> on Igor I was describing some struggles I was having with an internal urge to make better use of python's generators in Igor by building a concatinative design. Really the discussion devolved into a rant about some issues I was having, and I just wanted to do an update and say that I've solved some of them.</p>
<p>The first thing that I noticed was that I could dramatically simplify the pieces by putting all of the path management into the Config class. Not only does this make sense in the grand scheme of things (paths are actually part of the config) but it meant that opposed to spreading that work out over many functions, it was all nicely self contained where it mattered. The result is that the publish function is nearly half the weight of what it used to be.</p>
<pre><code>def publish(source, destination=""):
    config = Config(source, destination)

    posts = make_posts(config.posts_dir, extensions=list(markup.extensions()))
    HomePage(posts), Feed(posts), Archive(posts)

    context = dict(documents = Document.all(), **config)

    publisher = Publisher(config.destination, config.templates_dir, context)
    [publisher.publish(d) for d in Document.all()]
</code></pre>]]></summary>
        <content type="html"><![CDATA[<p>In the <a href="http://anders.conbere.org/blog/2009/08/22/concatinative_versus_object_oriented_design/">last post</a> on Igor I was describing some struggles I was having with an internal urge to make better use of python's generators in Igor by building a concatinative design. Really the discussion devolved into a rant about some issues I was having, and I just wanted to do an update and say that I've solved some of them.</p>
<p>The first thing that I noticed was that I could dramatically simplify the pieces by putting all of the path management into the Config class. Not only does this make sense in the grand scheme of things (paths are actually part of the config) but it meant that opposed to spreading that work out over many functions, it was all nicely self contained where it mattered. The result is that the publish function is nearly half the weight of what it used to be.</p>
<pre><code>def publish(source, destination=""):
    config = Config(source, destination)

    posts = make_posts(config.posts_dir, extensions=list(markup.extensions()))
    HomePage(posts), Feed(posts), Archive(posts)

    context = dict(documents = Document.all(), **config)

    publisher = Publisher(config.destination, config.templates_dir, context)
    [publisher.publish(d) for d in Document.all()]

    copy_supporting_files(config.source, config.destination)
</code></pre>
<p>versus...</p>
<pre><code>def publish(source, destination=""):
    paths = prepare_paths(source, destination)
    config = Config(paths['source'])

    paths['destination'] = paths['destination'] or config.get("publish_directory")
    assert(paths['destination'], "A destination directory is required")

    posts_path = path.join(paths['destination'], config.get("posts_prefix"))
    prepare_destination(paths['destination'])

    posts = find_posts(paths['source'], prefix=posts_dir, extensions=list(markup.extensions()))
    docs = posts + [HomePage(posts), Feed(posts), Archive(posts)]

    print(config)
    context = {'documents': documents}
    context.update(config)

    env = environment(paths['templates'], global_context=context)
    [write(doc, env, posts_path) for doc in docs]
    copy_supporting_files(paths['source'], paths['destination'])
</code></pre>
<p>Now I'm starting to feel good about this. My next goal is to abstract the source control tools being used. While my focuse is on Git, having it tightly bound seems like a bit of a cludge. And I suspect it will simplify some of the complexity found in the published_date, author, email etc. functions.</p>]]></content>
    </entry>
    
    <entry>
        <title>Learning to Program is Easy</title>
        <link rel="alternate" href="http://anders.conbere.org/blog/2011/05/03/learning_to_program_is_easy"/>
        <id>tag:anders.conbere.org,2011-05-03:1304473332.0</id>
        <updated>2011-05-03T18:42:12-07:00</updated>
        <published>2011-05-03T18:42:12-07:00</published>
        <summary type="html"><![CDATA[<p>Years ago I spent a summer teaching science classes to kids aged 6 to 12 at the Oregon Museum of Science and Industry. This program wasn't particularly well managed, mostly a disaster, but quite a bit of fun. The most fun I had was helping teach a class on game programming to 5th and 6th graders. The class used a pretty nice implementation of Logo called MicroWorlds which benefited from having a simple GUI and IDE for the kids to use. Maybe today we'd use something like <a href="http://scratch.mit.edu/">Scratch</a> or <a href="http://www.squeakland.org/">EToys</a>. Either way the class began with a simple introduction to making things happen in this virtual world, and some of the basics of the command structure. And within minutes there was a volley of hands that shot into the air each with it's very own bug.</p>
<p>That might not sounds like much, but by the time you've engaged someone to the point that they've typed in some commands and arrived at an unexpected occurrence... you've basically got them hook line and sinker. So that day and some of the next was often spent detailing the use of variables, the intricacies of syntax, and what rules exist and why they make their life easier. By the end of the week we would have flies narrowly dodging venus fly traps, and robots that had to defeat monsters.</p>
<p>I'm not saying every kid produced a work of genius, and some had more difficulties than others. But the nature of programming does not have to be a complex and difficult venture. Simply mapping input to a behavior gets you pretty far. This is a big part of the idea of Scheme. How do we build a language that is simple enough that our english majors can accomplish something in it, but powerful enough that our computer science students can develop complex ideas with it. The point is that most people can be taught to create at least rudimentary programs in just a few hours of tutorial.</p>
<p>And this really brings me to the reason I'm writing this post. And that is, that while programming might be easy, making applications, architecting large projects, putting all the various pieces together in a way that gives you the flexibility to accomplish what you <em>might</em> need to, but the structure to finishing what you <em>have</em> to, is amazingly difficult. And two different skills. You can teach someone to use python like a calculator, and to write functions that help them manage their bills. But the ability to take that knowledge and expand upon it to write a personal finance applications is much more difficult to teach.</p>
<p>Some of this is abstraction. Abstraction is difficult for humans, and I say this knowing that of all the creatures we've ever encountered we're likely the most capable abstractors in existence. But while that might be true, or brains are wired to work inside a rather constrained and physical world. There's a test that's often mentioned in literature where they ask the participants to accomplish a mathematical task using variable names, and then ask it again relating it to cards. In the first case most participants answer incorrectly, while in the next they do it with ease. The great difficult of mathematics as well as programming arrises from the depths of abstraction.</p>
<p>Just like Mathematics might be the deep study one abstract layer after another, complex application design mirrors this. While in mathematics at the bottom might be something like Category Theory from which derives Algebra from which derive the infinity of number systems from which derive Real and Complex numbers from which derive Real Analysis and then the Calculuses and on down the chain. A Complex application might have a User Interface which abstracts a Programable Interface which calls down into a Data Layer that then talks to a Persistence Layer that talks to the Operating System on down to the bare metal. Most of the extremely competent application architects I know might be considered a software version of a "tall, thin man". Someone who is familiar with all the ramifications of his design from the top layers to the cost at the bottom layers.</p>
<p>What I'm trying to say is that Programming might be easy. But the understanding of both the ramifications of the current environment (what can be done with the current language and tools) and the cost of the various layers below it, is hard. And that teaching THAT is much more difficult task than teaching someone how to use a fancy calculator. Books like SICP attempt to accomplish this task by dealing with abstraction in it's own right, by merging programing and mathematics and enabling a kind of cross pollination there of. But even that can leave a student with little understanding of how to put all the pieces together. I write this because my focus since college has been into the art of programming. And I'm beginning to understand where the limitations of my studies have been, and where I'm headed. And my new goal of trying to find more people to look at my code and find new ways of expressing those problems.</p>]]></summary>
        <content type="html"><![CDATA[<p>Years ago I spent a summer teaching science classes to kids aged 6 to 12 at the Oregon Museum of Science and Industry. This program wasn't particularly well managed, mostly a disaster, but quite a bit of fun. The most fun I had was helping teach a class on game programming to 5th and 6th graders. The class used a pretty nice implementation of Logo called MicroWorlds which benefited from having a simple GUI and IDE for the kids to use. Maybe today we'd use something like <a href="http://scratch.mit.edu/">Scratch</a> or <a href="http://www.squeakland.org/">EToys</a>. Either way the class began with a simple introduction to making things happen in this virtual world, and some of the basics of the command structure. And within minutes there was a volley of hands that shot into the air each with it's very own bug.</p>
<p>That might not sounds like much, but by the time you've engaged someone to the point that they've typed in some commands and arrived at an unexpected occurrence... you've basically got them hook line and sinker. So that day and some of the next was often spent detailing the use of variables, the intricacies of syntax, and what rules exist and why they make their life easier. By the end of the week we would have flies narrowly dodging venus fly traps, and robots that had to defeat monsters.</p>
<p>I'm not saying every kid produced a work of genius, and some had more difficulties than others. But the nature of programming does not have to be a complex and difficult venture. Simply mapping input to a behavior gets you pretty far. This is a big part of the idea of Scheme. How do we build a language that is simple enough that our english majors can accomplish something in it, but powerful enough that our computer science students can develop complex ideas with it. The point is that most people can be taught to create at least rudimentary programs in just a few hours of tutorial.</p>
<p>And this really brings me to the reason I'm writing this post. And that is, that while programming might be easy, making applications, architecting large projects, putting all the various pieces together in a way that gives you the flexibility to accomplish what you <em>might</em> need to, but the structure to finishing what you <em>have</em> to, is amazingly difficult. And two different skills. You can teach someone to use python like a calculator, and to write functions that help them manage their bills. But the ability to take that knowledge and expand upon it to write a personal finance applications is much more difficult to teach.</p>
<p>Some of this is abstraction. Abstraction is difficult for humans, and I say this knowing that of all the creatures we've ever encountered we're likely the most capable abstractors in existence. But while that might be true, or brains are wired to work inside a rather constrained and physical world. There's a test that's often mentioned in literature where they ask the participants to accomplish a mathematical task using variable names, and then ask it again relating it to cards. In the first case most participants answer incorrectly, while in the next they do it with ease. The great difficult of mathematics as well as programming arrises from the depths of abstraction.</p>
<p>Just like Mathematics might be the deep study one abstract layer after another, complex application design mirrors this. While in mathematics at the bottom might be something like Category Theory from which derives Algebra from which derive the infinity of number systems from which derive Real and Complex numbers from which derive Real Analysis and then the Calculuses and on down the chain. A Complex application might have a User Interface which abstracts a Programable Interface which calls down into a Data Layer that then talks to a Persistence Layer that talks to the Operating System on down to the bare metal. Most of the extremely competent application architects I know might be considered a software version of a "tall, thin man". Someone who is familiar with all the ramifications of his design from the top layers to the cost at the bottom layers.</p>
<p>What I'm trying to say is that Programming might be easy. But the understanding of both the ramifications of the current environment (what can be done with the current language and tools) and the cost of the various layers below it, is hard. And that teaching THAT is much more difficult task than teaching someone how to use a fancy calculator. Books like SICP attempt to accomplish this task by dealing with abstraction in it's own right, by merging programing and mathematics and enabling a kind of cross pollination there of. But even that can leave a student with little understanding of how to put all the pieces together. I write this because my focus since college has been into the art of programming. And I'm beginning to understand where the limitations of my studies have been, and where I'm headed. And my new goal of trying to find more people to look at my code and find new ways of expressing those problems.</p>]]></content>
    </entry>
    
</feed>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
        <title>Anders Conbere's 
Meat Flappings - Setup and Teardown Methods With Py.test
</title>
        <link rel="alternate" type="application/atom+xml" href="feed.atom" title="Meat Flappings - Feed">

        <link rel="stylesheet" type="text/css" media="screen" href="http://anders.conbere.org/media/css/base.css">
        <link rel="stylesheet" type="text/css" media="screen" href="http://anders.conbere.org/media/css/reset.css">
        <link rel="stylesheet" type="text/css" media="screen" href="http://anders.conbere.org/media/css/main.css">
        <link rel="stylesheet" type="text/css" media="screen" href="http://anders.conbere.org/media/css/fonts.css">
</head>

<body>
    <div id="header">
        
        <h3><a href="/">&lt;- Take me home</a></h3>
        <h1><a href="http://anders.conbere.org/blog/">Meat Flappings</a></h1>
        
    </div>

    <div id="content">
        
<div class="post">
    
    <div class="meta">
        <h3 id="document_title"><a href="http://anders.conbere.org/blog/2011/05/03/setup_and_teardown_methods_with_py.test">Setup and Teardown Methods With Py.test</a></h3>
        <p>Published on: <span class="published_on">2011-05-03 by Anders Conbere</span></p>
    </div>
    <div class="post_body">
    <p>Not so long ago I picked up my unittest's and headed out for greener pastures. My first stop was <a href="http://code.google.com/p/python-nose/">nosetest</a> but I found that I had a hard time getting all my tests to work. The naming conventions just didn't seem to work out the way I thought they did, and after a day of experimenting I moved onwards. I ended up settling down in a nice little valley called <a href="http://codespeak.net/py/dist/test/index.html">py.test</a>, part of the <a href="http://codespeak.net/py/dist/">py.lib</a> suite of tools. It has much the same flavor as nose tests. There are no explicit classes, all tests are collected via a naming scheme, but it just worked out better for me.</p>
<pre><code>def test_preferences():
    assert("I like py.test")
</code></pre>
<p>My needs were simple, the valley was fertile, life was good.</p>
<p>Now more recently I needed some more complex setup and teardown methods for Igor...and the valley grew a little darker. The documentation for this was split between two versions. Ian Bicking had a <a href="http://ianbicking.org/docs/pytest-presentation/pytest-slides.html">slide deck</a> up that documented using decorators to accomplish this task. But implementing that I got errors about guards. The <a href="http://codespeak.net/py/dist/test/funcargs.html#application-specific-test-setup-and-fixtures">online documentation</a> mentioned something about using funcargs but I really didn't get how it all came together, and didn't mention teardown.</p>
<p>So here's how you do it. </p>
<p>First let's talk a bit about funcargs. Funcargs is a little magic feature that reaches into your function definitions and looks at the arguments a function expects.</p>
<pre><code>def test_my_function(arg):
    assert(arg)
</code></pre>
<p>Then using the argument name, matches that against a function defined in a special python module conftest.py. So in this case it would look for.</p>
<pre><code>def pytest_funcarg__arg(request):
    return False
</code></pre>
<p>Now magically the result of pytest_funcarg__arg would show up as "arg" in test_my_function. This alone would solve our setup problem. But figuring out teardown requires that we know a little bit about that request variable. As it turns out this isn't particularly hard either! If for instance we wanted to test a database, installing a set of fixtures and then destroying them after our tests or setup might look like this.</p>
<pre><code># conftest.py
def setup_fixtures():
    db.insert(...)
    return db

def teardown_fixtures(db):
    db.destroy(..)

def py_test_funcarg__db(request):
    return request.cached_setup(
        setup = setup_fixtures,
        teardown = teardown_fixtures,
        scope = "module)

# test_db.py
def test_db(db):
    assert(len(db.query(x=y)) &gt;= 1)
</code></pre>
<p>This cached_setup stores the results of py_test_funcarg__db and reuses it for each test function in a given scope (here we're using module level scope). To instantiate the arg it calls the setup function, and when the scope exists it calls the teardown method with that arg.</p>
<p>I can't claim to like how magic all of this feels, but I do like that it works!</p>
    </div>
</div>

    </div>

    
    

    <div id="footer">
        
        <p>Generated with love by <a href="http://github.com/aconbere/igor/">Igor</a></p>
        
    </div>

    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
    var pageTracker = _gat._getTracker("UA-2522671-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
    
    
    
</body>
</html>